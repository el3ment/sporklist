{"ts":1352522296816,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php\n/**\n * Session class for Cake.\n *\n * Cake abstracts the handling of sessions.\n * There are several convenient methods to access session information.\n * This class is the implementation of those methods.\n * They are mostly used by the Session Component.\n *\n * PHP 5\n *\n * CakePHP(tm) : Rapid Development Framework (http://cakephp.org)\n * Copyright 2005-2012, Cake Software Foundation, Inc. (http://cakefoundation.org)\n *\n * Licensed under The MIT License\n * Redistributions of files must retain the above copyright notice.\n *\n * @copyright     Copyright 2005-2012, Cake Software Foundation, Inc. (http://cakefoundation.org)\n * @link          http://cakephp.org CakePHP(tm) Project\n * @package       Cake.Model.Datasource\n * @since         CakePHP(tm) v .0.10.0.1222\n * @license       MIT License (http://www.opensource.org/licenses/mit-license.php)\n */\n\nApp::uses('Hash', 'Utility');\nApp::uses('Security', 'Utility');\n\n/**\n * Session class for Cake.\n *\n * Cake abstracts the handling of sessions. There are several convenient methods to access session information.\n * This class is the implementation of those methods. They are mostly used by the Session Component.\n *\n * @package       Cake.Model.Datasource\n */\nclass CakeSession {\n\n/**\n * True if the Session is still valid\n *\n * @var boolean\n */\n\tpublic static $valid = false;\n\n/**\n * Error messages for this session\n *\n * @var array\n */\n\tpublic static $error = false;\n\n/**\n * User agent string\n *\n * @var string\n */\n\tprotected static $_userAgent = '';\n\n/**\n * Path to where the session is active.\n *\n * @var string\n */\n\tpublic static $path = '/';\n\n/**\n * Error number of last occurred error\n *\n * @var integer\n */\n\tpublic static $lastError = null;\n\n/**\n * Start time for this session.\n *\n * @var integer\n */\n\tpublic static $time = false;\n\n/**\n * Cookie lifetime\n *\n * @var integer\n */\n\tpublic static $cookieLifeTime;\n\n/**\n * Time when this session becomes invalid.\n *\n * @var integer\n */\n\tpublic static $sessionTime = false;\n\n/**\n * Current Session id\n *\n * @var string\n */\n\tpublic static $id = null;\n\n/**\n * Hostname\n *\n * @var string\n */\n\tpublic static $host = null;\n\n/**\n * Session timeout multiplier factor\n *\n * @var integer\n */\n\tpublic static $timeout = null;\n\n/**\n * Number of requests that can occur during a session time without the session being renewed.\n * This feature is only used when config value `Session.autoRegenerate` is set to true.\n *\n * @var integer\n * @see CakeSession::_checkValid()\n */\n\tpublic static $requestCountdown = 10;\n\n/**\n * Pseudo constructor.\n *\n * @param string $base The base path for the Session\n * @return void\n */\n\tpublic static function init($base = null) {\n\t\tself::$time = time();\n\n\t\t$checkAgent = Configure::read('Session.checkAgent');\n\t\tif (($checkAgent === true || $checkAgent === null) && env('HTTP_USER_AGENT') != null) {\n\t\t\tself::$_userAgent = md5(env('HTTP_USER_AGENT') . Configure::read('Security.salt'));\n\t\t}\n\t\tself::_setPath($base);\n\t\tself::_setHost(env('HTTP_HOST'));\n\n\t\tregister_shutdown_function('session_write_close');\n\t}\n\n/**\n * Setup the Path variable\n *\n * @param string $base base path\n * @return void\n */\n\tprotected static function _setPath($base = null) {\n\t\tif (empty($base)) {\n\t\t\tself::$path = '/';\n\t\t\treturn;\n\t\t}\n\t\tif (strpos($base, 'index.php') !== false) {\n\t\t\t $base = str_replace('index.php', '', $base);\n\t\t}\n\t\tif (strpos($base, '?') !== false) {\n\t\t\t $base = str_replace('?', '', $base);\n\t\t}\n\t\tself::$path = $base;\n\t}\n\n/**\n * Set the host name\n *\n * @param string $host Hostname\n * @return void\n */\n\tprotected static function _setHost($host) {\n\t\tself::$host = $host;\n\t\tif (strpos(self::$host, ':') !== false) {\n\t\t\tself::$host = substr(self::$host, 0, strpos(self::$host, ':'));\n\t\t}\n\t}\n\n/**\n * Starts the Session.\n *\n * @return boolean True if session was started\n */\n\tpublic static function start() {\n\t\tif (self::started()) {\n\t\t\treturn true;\n\t\t}\n\t\tself::init();\n\t\t$id = self::id();\n\t\tsession_write_close();\n\t\tself::_configureSession();\n\t\tself::_startSession();\n\n\t\tif (!$id && self::started()) {\n\t\t\tself::_checkValid();\n\t\t}\n\n\t\tself::$error = false;\n\t\treturn self::started();\n\t}\n\n/**\n * Determine if Session has been started.\n *\n * @return boolean True if session has been started.\n */\n\tpublic static function started() {\n\t\treturn isset($_SESSION) && session_id();\n\t}\n\n/**\n * Returns true if given variable is set in session.\n *\n * @param string $name Variable name to check for\n * @return boolean True if variable is there\n */\n\tpublic static function check($name = null) {\n\t\tif (!self::started() && !self::start()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (empty($name)) {\n\t\t\treturn false;\n\t\t}\n\t\t$result = Hash::get($_SESSION, $name);\n\t\treturn isset($result);\n\t}\n\n/**\n * Returns the Session id\n *\n * @param string $id\n * @return string Session id\n */\n\tpublic static function id($id = null) {\n\t\tif ($id) {\n\t\t\tself::$id = $id;\n\t\t\tsession_id(self::$id);\n\t\t}\n\t\tif (self::started()) {\n\t\t\treturn session_id();\n\t\t}\n\t\treturn self::$id;\n\t}\n\n/**\n * Removes a variable from session.\n *\n * @param string $name Session variable to remove\n * @return boolean Success\n */\n\tpublic static function delete($name) {\n\t\tif (self::check($name)) {\n\t\t\tself::_overwrite($_SESSION, Hash::remove($_SESSION, $name));\n\t\t\treturn (self::check($name) == false);\n\t\t}\n\t\tself::_setError(2, __d('cake_dev', \"%s doesn't exist\", $name));\n\t\treturn false;\n\t}\n\n/**\n * Used to write new data to _SESSION, since PHP doesn't like us setting the _SESSION var itself\n *\n * @param array $old Set of old variables => values\n * @param array $new New set of variable => value\n * @return void\n */\n\tprotected static function _overwrite(&$old, $new) {\n\t\tif (!empty($old)) {\n\t\t\tforeach ($old as $key => $var) {\n\t\t\t\tif (!isset($new[$key])) {\n\t\t\t\t\tunset($old[$key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tforeach ($new as $key => $var) {\n\t\t\t$old[$key] = $var;\n\t\t}\n\t}\n\n/**\n * Return error description for given error number.\n *\n * @param integer $errorNumber Error to set\n * @return string Error as string\n */\n\tprotected static function _error($errorNumber) {\n\t\tif (!is_array(self::$error) || !array_key_exists($errorNumber, self::$error)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn self::$error[$errorNumber];\n\t\t}\n\t}\n\n/**\n * Returns last occurred error as a string, if any.\n *\n * @return mixed Error description as a string, or false.\n */\n\tpublic static function error() {\n\t\tif (self::$lastError) {\n\t\t\treturn self::_error(self::$lastError);\n\t\t}\n\t\treturn false;\n\t}\n\n/**\n * Returns true if session is valid.\n *\n * @return boolean Success\n */\n\tpublic static function valid() {\n\t\tif (self::read('Config')) {\n\t\t\tif (self::_validAgentAndTime() && self::$error === false) {\n\t\t\t\tself::$valid = true;\n\t\t\t} else {\n\t\t\t\tself::$valid = false;\n\t\t\t\tself::_setError(1, 'Session Highjacking Attempted !!!');\n\t\t\t}\n\t\t}\n\t\treturn self::$valid;\n\t}\n\n/**\n * Tests that the user agent is valid and that the session hasn't 'timed out'.\n * Since timeouts are implemented in CakeSession it checks the current self::$time\n * against the time the session is set to expire.  The User agent is only checked\n * if Session.checkAgent == true.\n *\n * @return boolean\n */\n\tprotected static function _validAgentAndTime() {\n\t\t$config = self::read('Config');\n\t\t$validAgent = (\n\t\t\tConfigure::read('Session.checkAgent') === false ||\n\t\t\tself::$_userAgent == $config['userAgent']\n\t\t);\n\t\treturn ($validAgent && self::$time <= $config['time']);\n\t}\n\n/**\n * Get / Set the userAgent\n *\n * @param string $userAgent Set the userAgent\n * @return void\n */\n\tpublic static function userAgent($userAgent = null) {\n\t\tif ($userAgent) {\n\t\t\tself::$_userAgent = $userAgent;\n\t\t}\n\t\tif (empty(self::$_userAgent)) {\n\t\t\tCakeSession::init(self::$path);\n\t\t}\n\t\treturn self::$_userAgent;\n\t}\n\n/**\n * Returns given session variable, or all of them, if no parameters given.\n *\n * @param string|array $name The name of the session variable (or a path as sent to Set.extract)\n * @return mixed The value of the session variable\n */\n\tpublic static function read($name = null) {\n\t\tif (!self::started() && !self::start()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (is_null($name)) {\n\t\t\treturn self::_returnSessionVars();\n\t\t}\n\t\tif (empty($name)) {\n\t\t\treturn false;\n\t\t}\n\t\t$result = Hash::get($_SESSION, $name);\n\n\t\tif (isset($result)) {\n\t\t\treturn $result;\n\t\t}\n\t\tself::_setError(2, \"$name doesn't exist\");\n\t\treturn null;\n\t}\n\n/**\n * Returns all session variables.\n *\n * @return mixed Full $_SESSION array, or false on error.\n */\n\tprotected static function _returnSessionVars() {\n\t\tif (!empty($_SESSION)) {\n\t\t\treturn $_SESSION;\n\t\t}\n\t\tself::_setError(2, 'No Session vars set');\n\t\treturn false;\n\t}\n\n/**\n * Writes value to given session variable name.\n *\n * @param string|array $name Name of variable\n * @param string $value Value to write\n * @return boolean True if the write was successful, false if the write failed\n */\n\tpublic static function write($name, $value = null) {\n\t\tif (!self::started() && !self::start()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (empty($name)) {\n\t\t\treturn false;\n\t\t}\n\t\t$write = $name;\n\t\tif (!is_array($name)) {\n\t\t\t$write = array($name => $value);\n\t\t}\n\t\tforeach ($write as $key => $val) {\n\t\t\tself::_overwrite($_SESSION, Hash::insert($_SESSION, $key, $val));\n\t\t\tif (Hash::get($_SESSION, $key) !== $val) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n/**\n * Helper method to destroy invalid sessions.\n *\n * @return void\n */\n\tpublic static function destroy() {\n\t\tif (self::started()) {\n\t\t\tsession_destroy();\n\t\t}\n\t\tself::clear();\n\t}\n\n/**\n * Clears the session, the session id, and renew's the session.\n *\n * @return void\n */\n\tpublic static function clear() {\n\t\t$_SESSION = null;\n\t\tself::$id = null;\n\t\tself::start();\n\t\tself::renew();\n\t}\n\n/**\n * Helper method to initialize a session, based on Cake core settings.\n *\n * Sessions can be configured with a few shortcut names as well as have any number of ini settings declared.\n *\n * @return void\n * @throws CakeSessionException Throws exceptions when ini_set() fails.\n */\n\tprotected static function _configureSession() {\n\t\t$sessionConfig = Configure::read('Session');\n\n\t\tif (isset($sessionConfig['defaults'])) {\n\t\t\t$defaults = self::_defaultConfig($sessionConfig['defaults']);\n\t\t\tif ($defaults) {\n\t\t\t\t$sessionConfig = Hash::merge($defaults, $sessionConfig);\n\t\t\t}\n\t\t}\n\t\tif (!isset($sessionConfig['ini']['session.cookie_secure']) && env('HTTPS')) {\n\t\t\t$sessionConfig['ini']['session.cookie_secure'] = 1;\n\t\t}\n\t\tif (isset($sessionConfig['timeout']) && !isset($sessionConfig['cookieTimeout'])) {\n\t\t\t$sessionConfig['cookieTimeout'] = $sessionConfig['timeout'];\n\t\t}\n\t\tif (!isset($sessionConfig['ini']['session.cookie_lifetime'])) {\n\t\t\t$sessionConfig['ini']['session.cookie_lifetime'] = $sessionConfig['cookieTimeout'] * 60;\n\t\t}\n\t\tif (!isset($sessionConfig['ini']['session.name'])) {\n\t\t\t$sessionConfig['ini']['session.name'] = $sessionConfig['cookie'];\n\t\t}\n\t\tif (!empty($sessionConfig['handler'])) {\n\t\t\t$sessionConfig['ini']['session.save_handler'] = 'user';\n\t\t}\n\t\tif (!isset($sessionConfig['ini']['session.gc_maxlifetime'])) {\n\t\t\t$sessionConfig['ini']['session.gc_maxlifetime'] = $sessionConfig['timeout'] * 60;\n\t\t}\n\t\tif (!isset($sessionConfig['ini']['session.cookie_httponly'])) {\n\t\t\t$sessionConfig['ini']['session.cookie_httponly'] = 1;\n\t\t}\n\n\t\tif (empty($_SESSION)) {\n\t\t\tif (!empty($sessionConfig['ini']) && is_array($sessionConfig['ini'])) {\n\t\t\t\tforeach ($sessionConfig['ini'] as $setting => $value) {\n\t\t\t\t\tif (ini_set($setting, $value) === false) {\n\t\t\t\t\t\tthrow new CakeSessionException(sprintf(\n\t\t\t\t\t\t\t__d('cake_dev', 'Unable to configure the session, setting %s failed.'),\n\t\t\t\t\t\t\t$setting\n\t\t\t\t\t\t));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!empty($sessionConfig['handler']) && !isset($sessionConfig['handler']['engine'])) {\n\t\t\tcall_user_func_array('session_set_save_handler', $sessionConfig['handler']);\n\t\t}\n\t\tif (!empty($sessionConfig['handler']['engine'])) {\n\t\t\t$handler = self::_getHandler($sessionConfig['handler']['engine']);\n\t\t\tsession_set_save_handler(\n\t\t\t\tarray($handler, 'open'),\n\t\t\t\tarray($handler, 'close'),\n\t\t\t\tarray($handler, 'read'),\n\t\t\t\tarray($handler, 'write'),\n\t\t\t\tarray($handler, 'destroy'),\n\t\t\t\tarray($handler, 'gc')\n\t\t\t);\n\t\t}\n\t\tConfigure::write('Session', $sessionConfig);\n\t\tself::$sessionTime = self::$time + ($sessionConfig['timeout'] * 60);\n\t}\n\n/**\n * Find the handler class and make sure it implements the correct interface.\n *\n * @param string $handler\n * @return void\n * @throws CakeSessionException\n */\n\tprotected static function _getHandler($handler) {\n\t\tlist($plugin, $class) = pluginSplit($handler, true);\n\t\tApp::uses($class, $plugin . 'Model/Datasource/Session');\n\t\tif (!class_exists($class)) {\n\t\t\tthrow new CakeSessionException(__d('cake_dev', 'Could not load %s to handle the session.', $class));\n\t\t}\n\t\t$handler = new $class();\n\t\tif ($handler instanceof CakeSessionHandlerInterface) {\n\t\t\treturn $handler;\n\t\t}\n\t\tthrow new CakeSessionException(__d('cake_dev', 'Chosen SessionHandler does not implement CakeSessionHandlerInterface it cannot be used with an engine key.'));\n\t}\n\n/**\n * Get one of the prebaked default session configurations.\n *\n * @param string $name\n * @return boolean|array\n */\n\tprotected static function _defaultConfig($name) {\n\t\t$defaults = array(\n\t\t\t'php' => array(\n\t\t\t\t'cookie' => 'CAKEPHP',\n\t\t\t\t'timeout' => 240,\n\t\t\t\t'ini' => array(\n\t\t\t\t\t'session.use_trans_sid' => 0,\n\t\t\t\t\t'session.cookie_path' => self::$path\n\t\t\t\t)\n\t\t\t),\n\t\t\t'cake' => array(\n\t\t\t\t'cookie' => 'CAKEPHP',\n\t\t\t\t'timeout' => 240,\n\t\t\t\t'ini' => array(\n\t\t\t\t\t'session.use_trans_sid' => 0,\n\t\t\t\t\t'url_rewriter.tags' => '',\n\t\t\t\t\t'session.serialize_handler' => 'php',\n\t\t\t\t\t'session.use_cookies' => 1,\n\t\t\t\t\t'session.cookie_path' => self::$path,\n\t\t\t\t\t'session.auto_start' => 0,\n\t\t\t\t\t'session.save_path' => TMP . 'sessions',\n\t\t\t\t\t'session.save_handler' => 'files'\n\t\t\t\t)\n\t\t\t),\n\t\t\t'cache' => array(\n\t\t\t\t'cookie' => 'CAKEPHP',\n\t\t\t\t'timeout' => 240,\n\t\t\t\t'ini' => array(\n\t\t\t\t\t'session.use_trans_sid' => 0,\n\t\t\t\t\t'url_rewriter.tags' => '',\n\t\t\t\t\t'session.auto_start' => 0,\n\t\t\t\t\t'session.use_cookies' => 1,\n\t\t\t\t\t'session.cookie_path' => self::$path,\n\t\t\t\t\t'session.save_handler' => 'user',\n\t\t\t\t),\n\t\t\t\t'handler' => array(\n\t\t\t\t\t'engine' => 'CacheSession',\n\t\t\t\t\t'config' => 'default'\n\t\t\t\t)\n\t\t\t),\n\t\t\t'database' => array(\n\t\t\t\t'cookie' => 'CAKEPHP',\n\t\t\t\t'timeout' => 240,\n\t\t\t\t'ini' => array(\n\t\t\t\t\t'session.use_trans_sid' => 0,\n\t\t\t\t\t'url_rewriter.tags' => '',\n\t\t\t\t\t'session.auto_start' => 0,\n\t\t\t\t\t'session.use_cookies' => 1,\n\t\t\t\t\t'session.cookie_path' => self::$path,\n\t\t\t\t\t'session.save_handler' => 'user',\n\t\t\t\t\t'session.serialize_handler' => 'php',\n\t\t\t\t),\n\t\t\t\t'handler' => array(\n\t\t\t\t\t'engine' => 'DatabaseSession',\n\t\t\t\t\t'model' => 'Session'\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t\tif (isset($defaults[$name])) {\n\t\t\treturn $defaults[$name];\n\t\t}\n\t\treturn false;\n\t}\n\n/**\n * Helper method to start a session\n *\n * @return boolean Success\n */\n\tprotected static function _startSession() {\n\t\tif (headers_sent()) {\n\t\t\tif (empty($_SESSION)) {\n\t\t\t\t$_SESSION = array();\n\t\t\t}\n\t\t} else {\n\t\t\t// For IE<=8\n\t\t\tsession_cache_limiter(\"must-revalidate\");\n\t\t\tsession_start();\n\t\t}\n\t\treturn true;\n\t}\n\n/**\n * Helper method to create a new session.\n *\n * @return void\n */\n\tprotected static function _checkValid() {\n\t\tif (!self::started() && !self::start()) {\n\t\t\tself::$valid = false;\n\t\t\treturn false;\n\t\t}\n\t\tif ($config = self::read('Config')) {\n\t\t\t$sessionConfig = Configure::read('Session');\n\n\t\t\tif (self::_validAgentAndTime()) {\n\t\t\t\tself::write('Config.time', self::$sessionTime);\n\t\t\t\tif (isset($sessionConfig['autoRegenerate']) && $sessionConfig['autoRegenerate'] === true) {\n\t\t\t\t\t$check = $config['countdown'];\n\t\t\t\t\t$check -= 1;\n\t\t\t\t\tself::write('Config.countdown', $check);\n\n\t\t\t\t\tif ($check < 1) {\n\t\t\t\t\t\tself::renew();\n\t\t\t\t\t\tself::write('Config.countdown', self::$requestCountdown);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tself::$valid = true;\n\t\t\t} else {\n\t\t\t\tself::destroy();\n\t\t\t\tself::$valid = false;\n\t\t\t\tself::_setError(1, 'Session Highjacking Attempted !!!');\n\t\t\t}\n\t\t} else {\n\t\t\tself::write('Config.userAgent', self::$_userAgent);\n\t\t\tself::write('Config.time', self::$sessionTime);\n\t\t\tself::write('Config.countdown', self::$requestCountdown);\n\t\t\tself::$valid = true;\n\t\t}\n\t}\n\n/**\n * Restarts this session.\n *\n * @return void\n */\n\tpublic static function renew() {\n\t\tif (session_id()) {\n\t\t\tif (session_id() != '' || isset($_COOKIE[session_name()])) {\n\t\t\t\tsetcookie(Configure::read('Session.cookie'), '', time() - 42000, self::$path);\n\t\t\t}\n\t\t\tsession_regenerate_id(true);\n\t\t}\n\t}\n\n/**\n * Helper method to set an internal error message.\n *\n * @param integer $errorNumber Number of the error\n * @param string $errorMessage Description of the error\n * @return void\n */\n\tprotected static function _setError($errorNumber, $errorMessage) {\n\t\tif (self::$error === false) {\n\t\t\tself::$error = array();\n\t\t}\n\t\tself::$error[$errorNumber] = $errorMessage;\n\t\tself::$lastError = $errorNumber;\n\t}\n\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":16681}]],"length":16681}
